# SQL Window Functions - Complete Guide

SQL window functions enable advanced calculations across sets of rows related to the current row without complex subqueries or joins. They provide powerful analytical capabilities while maintaining row-level detail.

## Table of Contents

- [[#What Are Window Functions?|What Are Window Functions?]]
- [[#Basic Window Function Syntax|Basic Window Function Syntax]]
- [[#OVER Clause|OVER Clause]]
- [[#PARTITION BY Clause|PARTITION BY Clause]]
- [[#ORDER BY Clause|ORDER BY Clause]]
- [[#FRAME Clause|FRAME Clause]]
- [[#Window Function Rules|Window Function Rules]]
- [[#Window Functions with GROUP BY|Window Functions with GROUP BY]]
- [[#Quick Reference|Quick Reference]]

---

## What Are Window Functions?

Window functions perform calculations across a set of table rows related to the current row, similar to aggregate functions, but **without collapsing rows into groups**. They maintain the original row structure while adding analytical insights.

### Key Benefits:

- Keep individual row details while adding aggregate calculations
- Avoid complex subqueries and self-joins
- Enable advanced analytics like running totals, rankings, and comparisons

---

## Basic Window Function Syntax

```sql
function_name() OVER (
    [PARTITION BY column1, column2, ...]
    [ORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...]
    [ROWS/RANGE frame_specification]
)
```

### Traditional Aggregation vs Window Functions

**Traditional Aggregation (Loses Row Detail):**

```sql
-- Task 1: Calculate Total Sales Across All Orders
SELECT SUM(Sales) AS Total_Sales
FROM Sales.Orders;
```

**Output:**

```
Total_Sales
-----------
125000
```

**Traditional Grouping (Loses Other Row Details):**

```sql
-- Task 2: Calculate Total Sales for Each Product
SELECT 
    ProductID,
    SUM(Sales) AS Total_Sales
FROM Sales.Orders
GROUP BY ProductID;
```

**Output:**

```
ProductID | Total_Sales
----------|------------
101       | 25000
102       | 35000
103       | 65000
```

---

## OVER Clause

The `OVER` clause transforms an aggregate function into a window function, maintaining all row details while adding aggregate calculations.

### Basic OVER Usage

```sql
-- Task 3: Total sales with individual order details
SELECT
    OrderID,
    OrderDate,
    ProductID,
    Sales,
    SUM(Sales) OVER () AS Total_Sales
FROM Sales.Orders;
```

**Output:**

```
OrderID | OrderDate  | ProductID | Sales | Total_Sales
--------|------------|-----------|-------|------------
1001    | 2024-01-15 | 101       | 1500  | 125000
1002    | 2024-01-16 | 102       | 2200  | 125000
1003    | 2024-01-17 | 101       | 1800  | 125000
1004    | 2024-01-18 | 103       | 3200  | 125000
...     | ...        | ...       | ...   | 125000
```

> [!note] Key Insight Notice how `SUM(Sales) OVER ()` provides the total sales (125000) for every row, while preserving all individual order details. The empty parentheses `()` mean "consider all rows as one window."

---

## PARTITION BY Clause

`PARTITION BY` divides the result set into groups (partitions) and applies the window function to each partition separately.

### Single Partition

```sql
-- Task 4: Total sales by product with order details
SELECT
    OrderID,
    OrderDate,
    ProductID,
    Sales,
    SUM(Sales) OVER () AS Total_Sales,
    SUM(Sales) OVER (PARTITION BY ProductID) AS Sales_By_Product
FROM Sales.Orders;
```

**Output:**

```
OrderID | OrderDate  | ProductID | Sales | Total_Sales | Sales_By_Product
--------|------------|-----------|-------|-------------|------------------
1001    | 2024-01-15 | 101       | 1500  | 125000      | 25000
1003    | 2024-01-17 | 101       | 1800  | 125000      | 25000
1005    | 2024-01-19 | 101       | 2100  | 125000      | 25000
1002    | 2024-01-16 | 102       | 2200  | 125000      | 35000
1006    | 2024-01-20 | 102       | 2800  | 125000      | 35000
1004    | 2024-01-18 | 103       | 3200  | 125000      | 65000
...     | ...        | ...       | ...   | ...         | ...
```

### Multiple Partitions

```sql
-- Task 5: Sales by product and order status combination
SELECT
    OrderID,
    OrderDate,
    ProductID,
    OrderStatus,
    Sales,
    SUM(Sales) OVER () AS Total_Sales,
    SUM(Sales) OVER (PARTITION BY ProductID) AS Sales_By_Product,
    SUM(Sales) OVER (PARTITION BY ProductID, OrderStatus) AS Sales_By_Product_Status
FROM Sales.Orders;
```

**Output:**

```
OrderID | ProductID | OrderStatus | Sales | Total_Sales | Sales_By_Product | Sales_By_Product_Status
--------|-----------|-------------|-------|-------------|------------------|------------------------
1001    | 101       | Completed   | 1500  | 125000      | 25000            | 18000
1003    | 101       | Completed   | 1800  | 125000      | 25000            | 18000
1005    | 101       | Pending     | 2100  | 125000      | 25000            | 7000
1002    | 102       | Completed   | 2200  | 125000      | 35000            | 28000
1006    | 102       | Pending     | 2800  | 125000      | 35000            | 7000
```

> [!tip] Understanding Partitions Think of `PARTITION BY` like `GROUP BY`, but instead of collapsing rows, it creates "windows" for calculations while keeping all row details intact.

---

## ORDER BY Clause

`ORDER BY` within the window function determines the sequence for calculations and enables ranking functions.

### Ranking Example

```sql
-- Task 6: Rank orders by sales amount
SELECT
    OrderID,
    OrderDate,
    Sales,
    RANK() OVER (ORDER BY Sales DESC) AS Rank_Sales
FROM Sales.Orders;
```

**Output:**

```
OrderID | OrderDate  | Sales | Rank_Sales
--------|------------|-------|------------
1004    | 2024-01-18 | 3200  | 1
1006    | 2024-01-20 | 2800  | 2
1002    | 2024-01-16 | 2200  | 3
1005    | 2024-01-19 | 2100  | 4
1003    | 2024-01-17 | 1800  | 5
1001    | 2024-01-15 | 1500  | 6
```

> [!note] Common Ranking Functions
> 
> - **RANK()**: Assigns same rank to ties, skips next rank(s)
> - **DENSE_RANK()**: Assigns same rank to ties, doesn't skip ranks
> - **ROW_NUMBER()**: Assigns unique sequential numbers (no ties)

---

## FRAME Clause

The frame clause defines which rows within the partition to include in the calculation relative to the current row.

### Frame Syntax Options

|Frame Specification|Description|
|---|---|
|`CURRENT ROW`|Only the current row|
|`n PRECEDING`|n rows before current row|
|`n FOLLOWING`|n rows after current row|
|`UNBOUNDED PRECEDING`|All rows from partition start to current|
|`UNBOUNDED FOLLOWING`|All rows from current to partition end|

### Current Row + Following Rows

```sql
-- Task 7: Sum current and next 2 orders by status
SELECT
    OrderID,
    OrderDate,
    ProductID,
    OrderStatus,
    Sales,
    SUM(Sales) OVER (
        PARTITION BY OrderStatus 
        ORDER BY OrderDate 
        ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING
    ) AS Total_Sales
FROM Sales.Orders;
```

**Output:**

```
OrderID | OrderDate  | OrderStatus | Sales | Total_Sales
--------|------------|-------------|-------|------------
1001    | 2024-01-15 | Completed   | 1500  | 5500  -- (1500+1800+2200)
1003    | 2024-01-17 | Completed   | 1800  | 6200  -- (1800+2200+2200)
1002    | 2024-01-16 | Completed   | 2200  | 4400  -- (2200+2200)
1004    | 2024-01-18 | Completed   | 2200  | 2200  -- (2200 only)
```

### Current Row + Preceding Rows

```sql
-- Task 8: Sum current and previous 2 orders by status
SELECT
    OrderID,
    OrderDate,
    ProductID,
    OrderStatus,
    Sales,
    SUM(Sales) OVER (
        PARTITION BY OrderStatus 
        ORDER BY OrderDate 
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS Total_Sales
FROM Sales.Orders;
```

### Preceding Rows Only

```sql
-- Task 9: Sum only previous 2 orders by status
SELECT
    OrderID,
    OrderDate,
    ProductID,
    OrderStatus,
    Sales,
    SUM(Sales) OVER (
        PARTITION BY OrderStatus 
        ORDER BY OrderDate 
        ROWS 2 PRECEDING
    ) AS Total_Sales
FROM Sales.Orders;
```

### Running Total (Cumulative Sum)

```sql
-- Task 10: Cumulative sales by order status
SELECT
    OrderID,
    OrderDate,
    ProductID,
    OrderStatus,
    Sales,
    SUM(Sales) OVER (
        PARTITION BY OrderStatus 
        ORDER BY OrderDate 
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS Running_Total
FROM Sales.Orders;
```

**Output:**

```
OrderID | OrderDate  | OrderStatus | Sales | Running_Total
--------|------------|-------------|-------|---------------
1001    | 2024-01-15 | Completed   | 1500  | 1500
1002    | 2024-01-16 | Completed   | 2200  | 3700  -- (1500+2200)
1003    | 2024-01-17 | Completed   | 1800  | 5500  -- (1500+2200+1800)
1004    | 2024-01-18 | Completed   | 2200  | 7700  -- (1500+2200+1800+2200)
```

### Simplified Running Total

```sql
-- Task 11: Alternative cumulative sum syntax
SELECT
    OrderID,
    OrderDate,
    ProductID,
    OrderStatus,
    Sales,
    SUM(Sales) OVER (
        PARTITION BY OrderStatus 
        ORDER BY OrderDate 
        ROWS UNBOUNDED PRECEDING
    ) AS Running_Total
FROM Sales.Orders;
```

> [!tip] Frame Clause Default When using `ORDER BY` without an explicit frame clause, the default is `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`, which creates a running total.

---

## Window Function Rules

### Rule 1: Usage Restrictions

Window functions can **only** be used in:

- `SELECT` clause
- `ORDER BY` clause

```sql
-- ❌ INVALID: Window function in WHERE clause
SELECT
    OrderID,
    OrderDate,
    ProductID,
    OrderStatus,
    Sales,
    SUM(Sales) OVER (PARTITION BY OrderStatus) AS Total_Sales
FROM Sales.Orders
WHERE SUM(Sales) OVER (PARTITION BY OrderStatus) > 100;  -- ERROR!
```

> [!warning] Common Error You cannot use window functions in WHERE, GROUP BY, or HAVING clauses. Use subqueries or CTEs if you need to filter based on window function results.

**Correct Approach:**

```sql
-- ✅ VALID: Using CTE to filter window function results
WITH order_totals AS (
    SELECT
        OrderID,
        OrderDate,
        ProductID,
        OrderStatus,
        Sales,
        SUM(Sales) OVER (PARTITION BY OrderStatus) AS Total_Sales
    FROM Sales.Orders
)
SELECT * 
FROM order_totals 
WHERE Total_Sales > 100;
```

### Rule 2: No Nesting

Window functions cannot be nested within other window functions:

```sql
-- ❌ INVALID: Nested window functions
SELECT
    OrderID,
    OrderDate,
    ProductID,
    OrderStatus,
    Sales,
    SUM(SUM(Sales) OVER (PARTITION BY OrderStatus)) OVER (PARTITION BY OrderStatus) AS Total_Sales  -- ERROR!
FROM Sales.Orders;
```

---

## Window Functions with GROUP BY

Window functions work seamlessly with `GROUP BY` to provide additional analytical insights on aggregated data.

```sql
-- Task 12: Rank customers by their total sales
SELECT
    CustomerID,
    SUM(Sales) AS Total_Sales,
    RANK() OVER (ORDER BY SUM(Sales) DESC) AS Rank_Customers
FROM Sales.Orders
GROUP BY CustomerID;
```

**Output:**

```
CustomerID | Total_Sales | Rank_Customers
-----------|-------------|----------------
C001       | 15000       | 1
C003       | 12500       | 2
C002       | 8500        | 3
C004       | 6200        | 4
C005       | 4800        | 5
```

> [!note] Execution Order
> 
> 1. `GROUP BY` creates grouped rows with aggregated values
> 2. Window function operates on these grouped results
> 3. This allows ranking or comparing aggregated values

---

## Quick Reference

### Common Window Functions

|Function|Purpose|Example|
|---|---|---|
|`ROW_NUMBER()`|Unique sequential numbering|`ROW_NUMBER() OVER (ORDER BY sales DESC)`|
|`RANK()`|Ranking with gaps for ties|`RANK() OVER (ORDER BY sales DESC)`|
|`DENSE_RANK()`|Ranking without gaps|`DENSE_RANK() OVER (ORDER BY sales DESC)`|
|`SUM()`|Running or partitioned totals|`SUM(sales) OVER (PARTITION BY region)`|
|`AVG()`|Moving or partitioned averages|`AVG(sales) OVER (ORDER BY date ROWS 3 PRECEDING)`|
|`COUNT()`|Running or partitioned counts|`COUNT(*) OVER (PARTITION BY status)`|
|`LAG()`|Previous row value|`LAG(sales, 1) OVER (ORDER BY date)`|
|`LEAD()`|Next row value|`LEAD(sales, 1) OVER (ORDER BY date)`|

### Frame Specifications

|Specification|Meaning|
|---|---|
|`ROWS CURRENT ROW`|Only current row|
|`ROWS n PRECEDING`|n rows before current|
|`ROWS BETWEEN n PRECEDING AND m FOLLOWING`|Range from n before to m after|
|`ROWS UNBOUNDED PRECEDING`|From partition start to current row|
|`ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`|Entire partition|

### Syntax Template

```sql
SELECT 
    column1,
    column2,
    aggregate_function() OVER (
        [PARTITION BY partition_column]
        [ORDER BY order_column [ASC|DESC]]
        [ROWS/RANGE frame_specification]
    ) AS window_result
FROM table_name;
```

---

## Tags

#sql #window-functions #analytics #over-clause #partition-by #ranking #running-totals #advanced-sql