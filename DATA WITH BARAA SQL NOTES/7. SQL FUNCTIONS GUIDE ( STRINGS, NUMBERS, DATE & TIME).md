# üîß Complete SQL Functions Guide

A comprehensive guide covering SQL String, Number, and Date/Time functions for efficient data manipulation and transformation.

## üìã Table of Contents

### üî§ String Functions

- [[#CONCAT - String Concatenation|CONCAT - String Concatenation]]
- [[#LOWER & UPPER - Case Transformation|LOWER & UPPER - Case Transformation]]
- [[#TRIM - Remove White Spaces|TRIM - Remove White Spaces]]
- [[#REPLACE - Replace or Remove Values|REPLACE - Replace or Remove Values]]
- [[#LEN - String Length|LEN - String Length]]
- [[#LEFT & RIGHT - Substring Extraction|LEFT & RIGHT - Substring Extraction]]
- [[#SUBSTRING - Extract Substrings|SUBSTRING - Extract Substrings]]
- [[#Function Nesting|Function Nesting]]

### üî¢ Number Functions

- [[#ROUND - Rounding Numbers|ROUND - Rounding Numbers]]
- [[#ABS - Absolute Value|ABS - Absolute Value]]

### üìÖ Date & Time Functions

- [[#GETDATE - Current Date and Time|GETDATE - Current Date and Time]]
- [[#Date Part Extractions|Date Part Extractions]]
- [[#DATETRUNC - Truncate Date Parts|DATETRUNC - Truncate Date Parts]]
- [[#EOMONTH - End of Month|EOMONTH - End of Month]]
- [[#FORMAT - Date and Number Formatting|FORMAT - Date and Number Formatting]]
- [[#CONVERT & CAST - Data Type Conversion|CONVERT & CAST - Data Type Conversion]]
- [[#DATEADD & DATEDIFF - Date Arithmetic|DATEADD & DATEDIFF - Date Arithmetic]]
- [[#ISDATE - Date Validation|ISDATE - Date Validation]]

### üìö Reference Tables

- [[#Format Specifiers Reference|Format Specifiers Reference]]
- [[#Culture Codes Reference|Culture Codes Reference]]

---

# üî§ String Functions

String functions allow you to manipulate, transform, and extract text data efficiently.

## CONCAT - String Concatenation

Combines multiple strings into a single string with optional separators.

```sql
-- Concatenate first name and country with a separator
SELECT 
    CONCAT(first_name, '-', country) AS full_info
FROM customers;
```

**Sample Output:**

```
full_info
---------
John-USA
Anna-Germany
Sam-Canada
```

> [!tip] CONCAT Benefits
> 
> - Handles NULL values gracefully (NULL + 'text' = 'text')
> - More readable than using + operator
> - Can concatenate multiple values in one function call

---

## LOWER & UPPER - Case Transformation

Convert text to lowercase or uppercase for consistent formatting.

```sql
-- Convert first name to lowercase
SELECT 
    first_name,
    LOWER(first_name) AS lower_case_name
FROM customers;

-- Convert first name to uppercase
SELECT 
    first_name,
    UPPER(first_name) AS upper_case_name
FROM customers;
```

**Sample Output:**

```
first_name | lower_case_name | upper_case_name
-----------|-----------------|----------------
John       | john            | JOHN
Anna       | anna            | ANNA
Sam        | sam             | SAM
```

> [!note] Use Cases
> 
> - **Data standardization**: Ensure consistent case in comparisons
> - **User input normalization**: Handle mixed-case user entries
> - **Display formatting**: Present data in specific case requirements

---

## TRIM - Remove White Spaces

Removes leading and trailing whitespace from strings.

```sql
-- Find customers with leading/trailing spaces in names
SELECT 
    first_name,
    LEN(first_name) AS len_name,
    LEN(TRIM(first_name)) AS len_trim_name,
    LEN(first_name) - LEN(TRIM(first_name)) AS spaces_removed
FROM customers
WHERE LEN(first_name) != LEN(TRIM(first_name));
```

**Sample Output:**

```
first_name | len_name | len_trim_name | spaces_removed
-----------|----------|---------------|---------------
 John      | 5        | 4             | 1
Anna       | 6        | 4             | 2
Sam        | 5        | 3             | 2
```

> [!warning] Data Quality Issue Leading/trailing spaces are common data quality problems that can cause:
> 
> - Failed string comparisons
> - Incorrect grouping in queries
> - Display formatting issues

---

## REPLACE - Replace or Remove Values

Substitutes all occurrences of a specified string with another string.

```sql
-- Remove dashes from phone numbers
SELECT
    '123-456-7890' AS phone,
    REPLACE('123-456-7890', '-', '') AS clean_phone,
    REPLACE('123-456-7890', '-', '/') AS formatted_phone;

-- Change file extensions
SELECT
    'report.txt' AS old_filename,
    REPLACE('report.txt', '.txt', '.csv') AS new_filename;
```

**Sample Output:**

```
phone        | clean_phone | formatted_phone
-------------|-------------|----------------
123-456-7890 | 1234567890  | 123/456/7890

old_filename | new_filename
-------------|-------------
report.txt   | report.csv
```

> [!tip] Common Use Cases
> 
> - **Data cleaning**: Remove unwanted characters
> - **Format standardization**: Replace separators
> - **Text sanitization**: Remove special characters

---

## LEN - String Length

Returns the number of characters in a string.

```sql
-- Calculate length of customer names
SELECT 
    first_name, 
    LEN(first_name) AS name_length
FROM customers;
```

**Sample Output:**

```
first_name | name_length
-----------|------------
John       | 4
Anna       | 4
Samuel     | 6
```

> [!note] Length vs Character Count
> 
> - `LEN()` excludes trailing spaces but includes leading spaces
> - Use with `TRIM()` for accurate character counting
> - Useful for data validation and field size checks

---

## LEFT & RIGHT - Substring Extraction

Extract characters from the beginning or end of a string.

```sql
-- Get first two characters of names
SELECT 
    first_name,
    LEFT(TRIM(first_name), 2) AS first_2_chars,
    RIGHT(first_name, 2) AS last_2_chars
FROM customers;
```

**Sample Output:**

```
first_name | first_2_chars | last_2_chars
-----------|---------------|-------------
John       | Jo            | hn
Anna       | An            | na
Samuel     | Sa            | el
```

> [!tip] Practical Applications
> 
> - **Initials generation**: Extract first letters
> - **Code creation**: Generate abbreviated identifiers
> - **Data categorization**: Group by first/last characters

---

## SUBSTRING - Extract Substrings

Extract a portion of a string starting at a specific position.

```sql
-- Remove first character from names
SELECT 
    first_name,
    SUBSTRING(TRIM(first_name), 2, LEN(first_name)) AS trimmed_name
FROM customers;
```

**Sample Output:**

```
first_name | trimmed_name
-----------|-------------
John       | ohn
Anna       | nna
Samuel     | amuel
```

**Syntax:** `SUBSTRING(string, start_position, length)`

- **start_position**: 1-based index where extraction begins
- **length**: Number of characters to extract

---

## Function Nesting

Combine multiple string functions for complex transformations.

```sql
-- Nested function example
SELECT
    first_name, 
    UPPER(LOWER(first_name)) AS normalized_name,
    CONCAT(LEFT(TRIM(first_name), 1), LOWER(RIGHT(first_name, LEN(first_name)-1))) AS title_case
FROM customers;
```

**Sample Output:**

```
first_name | normalized_name | title_case
-----------|-----------------|------------
john       | JOHN            | John
ANNA       | ANNA            | Anna
SaMuEl     | SAMUEL          | Samuel
```

> [!tip] Function Nesting Strategy
> 
> 1. **Work inside-out**: Start with innermost function
> 2. **Test incrementally**: Verify each function layer
> 3. **Consider performance**: Excessive nesting can slow queries

---

# üî¢ Number Functions

Number functions perform mathematical operations and format numerical values.

## ROUND - Rounding Numbers

Round numbers to specified decimal places.

```sql
-- Demonstrate different rounding precision
SELECT 
    3.516 AS original_number,
    ROUND(3.516, 2) AS round_2_decimals,
    ROUND(3.516, 1) AS round_1_decimal,
    ROUND(3.516, 0) AS round_whole_number;
```

**Sample Output:**

```
original_number | round_2_decimals | round_1_decimal | round_whole_number
----------------|------------------|-----------------|-------------------
3.516           | 3.52             | 3.5             | 4
```

> [!note] Rounding Rules
> 
> - **Positive precision**: Decimal places to keep
> - **Zero precision**: Round to nearest integer
> - **Negative precision**: Round to tens, hundreds, etc.

---

## ABS - Absolute Value

Returns the absolute (positive) value of a number.

```sql
-- Demonstrate absolute value function
SELECT 
    -10 AS negative_number,
    ABS(-10) AS absolute_negative,
    10 AS positive_number,
    ABS(10) AS absolute_positive;
```

**Sample Output:**

```
negative_number | absolute_negative | positive_number | absolute_positive
----------------|-------------------|-----------------|------------------
-10             | 10                | 10              | 10
```

> [!tip] Use Cases
> 
> - **Distance calculations**: Find differences between values
> - **Error analysis**: Calculate deviations from targets
> - **Data validation**: Ensure positive values for calculations

---

# üìÖ Date & Time Functions

Date and time functions handle temporal data manipulation, formatting, and calculations.

## GETDATE - Current Date and Time

Returns the current system date and time.

```sql
-- Display current date with order information
SELECT
    OrderID,
    CreationTime,
    '2025-08-20' AS hard_coded_date,
    GETDATE() AS current_datetime
FROM Sales.Orders;
```

**Sample Output:**

```
OrderID | CreationTime        | hard_coded_date | current_datetime
--------|---------------------|-----------------|------------------
1001    | 2025-01-15 10:30:00 | 2025-08-20      | 2025-07-24 14:25:33
1002    | 2025-01-16 14:45:00 | 2025-08-20      | 2025-07-24 14:25:33
```

> [!note] GETDATE() Characteristics
> 
> - Returns current server time (not client time)
> - Includes both date and time components
> - Updates with each query execution

---

## Date Part Extractions

Extract specific components from date/time values using multiple functions.

```sql
-- Extract various date parts
SELECT
    OrderID,
    CreationTime,
    -- DATETRUNC Examples (truncates to specified precision)
    DATETRUNC(year, CreationTime) AS year_truncated,
    DATETRUNC(month, CreationTime) AS month_truncated,
    DATETRUNC(day, CreationTime) AS day_truncated,
    -- DATENAME Examples (returns string names)
    DATENAME(month, CreationTime) AS month_name,
    DATENAME(weekday, CreationTime) AS weekday_name,
    -- DATEPART Examples (returns integer values)
    DATEPART(year, CreationTime) AS year_number,
    DATEPART(month, CreationTime) AS month_number,
    DATEPART(day, CreationTime) AS day_number,
    DATEPART(quarter, CreationTime) AS quarter_number,
    -- Dedicated functions
    YEAR(CreationTime) AS year_func,
    MONTH(CreationTime) AS month_func,
    DAY(CreationTime) AS day_func
FROM Sales.Orders;
```

**Sample Output:**

```
OrderID | CreationTime        | year_truncated | month_name | year_number | quarter_number
--------|---------------------|----------------|------------|-------------|---------------
1001    | 2025-01-15 10:30:00 | 2025-01-01     | January    | 2025        | 1
1002    | 2025-06-16 14:45:00 | 2025-01-01     | June       | 2025        | 2
```

### Function Comparison Table

| Function      | Purpose        | Return Type | Example Output        |     |
| ------------- | -------------- | ----------- | --------------------- | --- |
| **DATEPART**  | Numeric part   | Integer     | `1` (January)         |     |
| **DATENAME**  | Named part     | String      | `"January"`           |     |
| **DATETRUNC** | Truncated date | DateTime    | `2025-01-01 00:00:00` |     |

---

## DATETRUNC - Truncate Date Parts

Truncate dates to specific precision levels for grouping and analysis.

```sql
-- Aggregate orders by year using DATETRUNC
SELECT
    DATETRUNC(year, CreationTime) AS order_year,
    COUNT(*) AS order_count
FROM Sales.Orders
GROUP BY DATETRUNC(year, CreationTime)
ORDER BY order_year;
```

**Sample Output:**

```
order_year          | order_count
--------------------|------------
2023-01-01 00:00:00 | 150
2024-01-01 00:00:00 | 275
2025-01-01 00:00:00 | 89
```

> [!tip] DATETRUNC Use Cases
> 
> - **Time series analysis**: Group data by time periods
> - **Report generation**: Create monthly/yearly summaries
> - **Performance optimization**: Efficient date-based grouping

---

## EOMONTH - End of Month

Returns the last day of the month for a given date.

```sql
-- Find end of month for order dates
SELECT
    OrderID,
    CreationTime,
    EOMONTH(CreationTime) AS end_of_month,
    EOMONTH(CreationTime, 1) AS next_month_end,
    EOMONTH(CreationTime, -1) AS previous_month_end
FROM Sales.Orders;
```

**Sample Output:**

```
OrderID | CreationTime        | end_of_month | next_month_end | previous_month_end
--------|---------------------|--------------|----------------|-------------------
1001    | 2025-01-15 10:30:00 | 2025-01-31   | 2025-02-28     | 2024-12-31
1002    | 2025-06-16 14:45:00 | 2025-06-30   | 2025-07-31     | 2025-05-31
```

> [!note] EOMONTH Parameters
> 
> - **First parameter**: Base date
> - **Second parameter** (optional): Month offset
>     - Positive: Future months
>     - Negative: Past months
>     - Default: 0 (current month)

---

## Practical Date Analysis Examples

### Orders by Year

```sql
SELECT 
    YEAR(OrderDate) AS order_year, 
    COUNT(*) AS total_orders
FROM Sales.Orders
GROUP BY YEAR(OrderDate)
ORDER BY order_year;
```

### Orders by Month Name

```sql
SELECT 
    DATENAME(month, OrderDate) AS month_name, 
    COUNT(*) AS total_orders
FROM Sales.Orders
GROUP BY DATENAME(month, OrderDate), MONTH(OrderDate)
ORDER BY MONTH(OrderDate);
```

### February Orders Only

```sql
SELECT *
FROM Sales.Orders
WHERE MONTH(OrderDate) = 2;
```

**Sample Output:**

```
order_year | total_orders
-----------|-------------
2023       | 245
2024       | 387
2025       | 156

month_name | total_orders
-----------|-------------
January    | 67
February   | 58
March      | 72
```

---

## FORMAT - Date and Number Formatting

Format dates and numbers according to specific patterns and cultures.

### Basic Date Formatting

```sql
SELECT
    OrderID,
    CreationTime,
    FORMAT(CreationTime, 'MM-dd-yyyy') AS usa_format,
    FORMAT(CreationTime, 'dd-MM-yyyy') AS euro_format,
    FORMAT(CreationTime, 'yyyy-MM-dd') AS iso_format,
    FORMAT(CreationTime, 'MMMM dd, yyyy') AS long_format
FROM Sales.Orders;
```

### Advanced Custom Formatting

```sql
SELECT
    OrderID,
    CreationTime,
    'Day ' + FORMAT(CreationTime, 'ddd MMM') +
    ' Q' + DATENAME(quarter, CreationTime) + ' ' +
    FORMAT(CreationTime, 'yyyy hh:mm:ss tt') AS custom_format
FROM Sales.Orders;
```

**Sample Output:**

```
OrderID | usa_format | euro_format | custom_format
--------|------------|-------------|--------------------------------
1001    | 01-15-2025 | 15-01-2025  | Day Wed Jan Q1 2025 10:30:00 AM
1002    | 06-16-2025 | 16-06-2025  | Day Mon Jun Q2 2025 02:45:00 PM
```

### Monthly Order Analysis with Formatting

```sql
SELECT
    FORMAT(CreationTime, 'MMM yy') AS order_period,
    COUNT(*) AS total_orders
FROM Sales.Orders
GROUP BY FORMAT(CreationTime, 'MMM yy')
ORDER BY MIN(CreationTime);
```

---

## CONVERT & CAST - Data Type Conversion

Convert data between different data types using two different approaches.

### CONVERT Function

```sql
SELECT
    CONVERT(INT, '123') AS string_to_int,
    CONVERT(DATE, '2025-08-20') AS string_to_date,
    CreationTime,
    CONVERT(DATE, CreationTime) AS datetime_to_date,
    CONVERT(VARCHAR, CreationTime, 32) AS usa_style,
    CONVERT(VARCHAR, CreationTime, 34) AS euro_style
FROM Sales.Orders;
```

### CAST Function

```sql
SELECT
    CAST('123' AS INT) AS string_to_int,
    CAST(123 AS VARCHAR) AS int_to_string,
    CAST('2025-08-20' AS DATE) AS string_to_date,
    CAST('2025-08-20' AS DATETIME2) AS string_to_datetime,
    CreationTime,
    CAST(CreationTime AS DATE) AS datetime_to_date
FROM Sales.Orders;
```

**Sample Output:**

```
string_to_int | string_to_date | usa_style           | euro_style
--------------|----------------|---------------------|--------------------
123           | 2025-08-20     | Jan 15 2025 10:30AM | 15 Jan 2025 10:30:00
```

### CONVERT vs CAST Comparison

|Aspect|CONVERT|CAST|
|---|---|---|
|**Standard**|SQL Server specific|ANSI SQL standard|
|**Style options**|Yes (third parameter)|No|
|**Readability**|Less readable|More readable|
|**Portability**|Limited|High|

> [!tip] When to Use Which
> 
> - **Use CAST**: For simple conversions, better portability
> - **Use CONVERT**: When you need specific formatting styles

---

## DATEADD & DATEDIFF - Date Arithmetic

Perform calculations with dates - adding/subtracting time periods and finding differences.

### DATEADD - Adding Time Periods

```sql
SELECT
    OrderID,
    OrderDate,
    DATEADD(day, -10, OrderDate) AS ten_days_before,
    DATEADD(month, 3, OrderDate) AS three_months_later,
    DATEADD(year, 2, OrderDate) AS two_years_later,
    DATEADD(hour, 48, OrderDate) AS forty_eight_hours_later
FROM Sales.Orders;
```

### DATEDIFF - Calculating Differences

```sql
-- Calculate employee ages
SELECT
    EmployeeID,
    BirthDate,
    DATEDIFF(year, BirthDate, GETDATE()) AS age_years,
    DATEDIFF(day, BirthDate, GETDATE()) AS age_days
FROM Sales.Employees;

-- Average shipping duration by month
SELECT
    MONTH(OrderDate) AS order_month,
    AVG(DATEDIFF(day, OrderDate, ShipDate)) AS avg_shipping_days
FROM Sales.Orders
WHERE ShipDate IS NOT NULL
GROUP BY MONTH(OrderDate)
ORDER BY order_month;
```

### Advanced: Time Gap Analysis

```sql
-- Find days between consecutive orders
SELECT
    OrderID,
    OrderDate AS current_order_date,
    LAG(OrderDate) OVER (ORDER BY OrderDate) AS previous_order_date,
    DATEDIFF(day, LAG(OrderDate) OVER (ORDER BY OrderDate), OrderDate) AS days_between_orders
FROM Sales.Orders
ORDER BY OrderDate;
```

**Sample Output:**

```
OrderID | current_order_date | previous_order_date | days_between_orders
--------|-------------------|--------------------|--------------------|
1001    | 2025-01-15        | NULL               | NULL
1002    | 2025-01-18        | 2025-01-15         | 3
1003    | 2025-01-22        | 2025-01-18         | 4

order_month | avg_shipping_days
------------|------------------
1           | 3.5
2           | 2.8
3           | 4.1
```

> [!note] DATEPART Units Common units for DATEADD/DATEDIFF:
> 
> - `year`, `quarter`, `month`, `week`, `day`
> - `hour`, `minute`, `second`, `millisecond`

---

## ISDATE - Date Validation

Validate whether a string can be converted to a valid date.

```sql
-- Validate date strings and handle invalid dates
SELECT
    date_string,
    ISDATE(date_string) AS is_valid_date,
    CASE 
        WHEN ISDATE(date_string) = 1 THEN CAST(date_string AS DATE)
        ELSE '9999-01-01'  -- Default date for invalid entries
    END AS converted_date
FROM (
    SELECT '2025-08-20' AS date_string UNION
    SELECT '2025-08-21' UNION
    SELECT '2025-13-01' UNION  -- Invalid month
    SELECT '2025-08-32' UNION  -- Invalid day
    SELECT '2025-08' UNION     -- Incomplete date
    SELECT 'not-a-date'        -- Invalid format
) AS test_dates;
```

**Sample Output:**

```
date_string | is_valid_date | converted_date
------------|---------------|---------------
2025-08-20  | 1             | 2025-08-20
2025-08-21  | 1             | 2025-08-21
2025-13-01  | 0             | 9999-01-01
2025-08-32  | 0             | 9999-01-01
2025-08     | 0             | 9999-01-01
not-a-date  | 0             | 9999-01-01
```

> [!warning] Date Validation Best Practice Always validate date strings before conversion to prevent runtime errors:
> 
> ```sql
> WHERE ISDATE(date_column) = 1  -- Filter valid dates only
> ```

---

# üìö Reference Tables

## Format Specifiers Reference

### Numeric Format Specifiers

|Format|Description|Example Input|Example Output|
|---|---|---|---|
|`N`|Number with thousand separators|1234.56|1,234.56|
|`P`|Percentage|0.1234|12.34%|
|`C`|Currency|1234.56|$1,234.56|
|`E`|Scientific notation|1234.56|1.234560E+003|
|`F`|Fixed-point|1234.56|1234.56|
|`N0`|Number, no decimals|1234.56|1,235|
|`N2`|Number, 2 decimals|1234.56|1,234.56|

### Date Format Specifiers

|Format|Description|Example Output|
|---|---|---|
|`D`|Full date pattern|Wednesday, July 24, 2025|
|`d`|Short date pattern|7/24/2025|
|`dd`|Day with leading zero|24|
|`ddd`|Abbreviated day name|Wed|
|`dddd`|Full day name|Wednesday|
|`MM`|Month with leading zero|07|
|`MMM`|Abbreviated month name|Jul|
|`MMMM`|Full month name|July|
|`yy`|Two-digit year|25|
|`yyyy`|Four-digit year|2025|
|`hh`|Hour (12-hour) with leading zero|02|
|`HH`|Hour (24-hour) with leading zero|14|
|`mm`|Minutes with leading zero|30|
|`ss`|Seconds with leading zero|45|
|`tt`|AM/PM designator|PM|

---

## Culture Codes Reference

### Popular Culture Codes for FORMAT()

|Culture Code|Country/Region|Number Format|Date Format|
|---|---|---|---|
|`en-US`|United States|1,234.56|7/24/2025|
|`en-GB`|United Kingdom|1,234.56|24/07/2025|
|`fr-FR`|France|1 234,56|24/07/2025|
|`de-DE`|Germany|1.234,56|24.07.2025|
|`es-ES`|Spain|1.234,56|24/07/2025|
|`it-IT`|Italy|1.234,56|24/07/2025|
|`ja-JP`|Japan|1,234.56|2025/07/24|
|`zh-CN`|China|1,234.56|2025/7/24|

### Using Culture Codes

```sql
SELECT 
    FORMAT(1234567.89, 'N', 'en-US') AS usa_format,     -- 1,234,567.89
    FORMAT(1234567.89, 'N', 'de-DE') AS german_format,  -- 1.234.567,89
    FORMAT(GETDATE(), 'D', 'fr-FR') AS french_date;     -- mercredi 24 juillet 2025
```

---

## DATEPART Units Reference

|Unit|Abbreviations|Description|Example|
|---|---|---|---|
|`year`|`yy`, `yyyy`|Year|2025|
|`quarter`|`qq`, `q`|Quarter (1-4)|3|
|`month`|`mm`, `m`|Month (1-12)|7|
|`dayofyear`|`dy`, `y`|Day of year (1-366)|205|
|`day`|`dd`, `d`|Day of month (1-31)|24|
|`week`|`wk`, `ww`|Week of year (1-53)|30|
|`weekday`|`dw`|Day of week (1-7)|4|
|`hour`|`hh`|Hour (0-23)|14|
|`minute`|`mi`, `n`|Minute (0-59)|30|
|`second`|`ss`, `s`|Second (0-59)|45|
|`millisecond`|`ms`|Millisecond (0-999)|123|

---

## üí° Best Practices & Tips

### String Function Best Practices

1. **Always use TRIM()** when working with user input data
2. **Combine UPPER/LOWER** with comparisons for case-insensitive searches
3. **Use LEN()** to validate field lengths before insertion
4. **Nest functions carefully** - test each layer independently

### Date Function Best Practices

1. **Use DATETRUNC()** for efficient date-based grouping
2. **Always validate dates** with ISDATE() before conversion
3. **Consider time zones** when using GETDATE()
4. **Use appropriate data types** - DATE vs DATETIME2 vs DATETIMEOFFSET

### Performance Tips

1. **Avoid functions in WHERE clauses** on indexed columns
2. **Use SARGABLE queries** - move functions to the right side of comparisons
3. **Consider computed columns** for frequently used function results
4. **Test with realistic data volumes** to identify performance bottlenecks

### Common Pitfalls to Avoid

- **String functions on NULL values** return NULL
- **Date arithmetic** with different data types can cause errors
- **Culture-specific formatting** may not work in all environments
- **Excessive function nesting** reduces query readability and performance

---

## üîç Quick Function Lookup

### String Functions

```sql
CONCAT(str1, str2, ...)     -- Concatenate strings
LOWER(string)               -- Convert to lowercase
UPPER(string)               -- Convert to uppercase
TRIM(string)                -- Remove leading/trailing spaces
REPLACE(string, old, new)   -- Replace occurrences
LEN(string)                 -- String length
LEFT(string, length)        -- Extract from left
RIGHT(string, length)       -- Extract from right
SUBSTRING(string, start, len) -- Extract substring
```

### Number Functions

```sql
ROUND(number, precision)    -- Round to decimal places
ABS(number)                 -- Absolute value
```

### Date Functions

```sql
GETDATE()                   -- Current date/time
DATEPART(part, date)        -- Extract date part (integer)
DATENAME(part, date)        -- Extract date part (string)
DATETRUNC(part, date)       -- Truncate to precision
EOMONTH(date, [offset])     -- End of month
FORMAT(value, format, [culture]) -- Format date/number
CONVERT(type, value, [style])    -- Convert data type
CAST(value AS type)         -- Convert data type (ANSI)
DATEADD(part, number, date) -- Add time period
DATEDIFF(part, start, end)  -- Calculate difference
ISDATE(string)              -- Validate date string
```

---

## Tags

#sql #database #functions #string-functions #date-functions #number-functions #data-manipulation #formatting #conversion #reference-guide