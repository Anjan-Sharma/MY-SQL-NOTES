# SQL Window Aggregate Functions - Complete Guide

Window functions are powerful SQL tools that allow you to perform aggregate calculations over a set of rows **without collapsing the result set**. Unlike regular aggregate functions that require GROUP BY and reduce rows, window functions maintain individual row details while providing aggregate insights.

## ğŸ¯ Key Concepts

> [!note] What Makes Window Functions Special?
> 
> - **Preserve individual rows** - No need for GROUP BY
> - **Flexible partitioning** - Group calculations by specific criteria
> - **Ordering capabilities** - Create rolling calculations
> - **Advanced analytics** - Moving averages, running totals, rankings

## ğŸ“‹ Table of Contents

- [[#ğŸ”¢ COUNT Functions|ğŸ”¢ COUNT Functions]]
- [[#â• SUM Functions|â• SUM Functions]]
- [[#ğŸ“Š AVG Functions|ğŸ“Š AVG Functions]]
- [[#ğŸ“ˆ MAX MIN Functions|ğŸ“ˆ MAX/MIN Functions]]
- [[#ğŸ”„ Rolling Calculations|ğŸ”„ Rolling Calculations]]
- [[#ğŸš€ Quick Reference|ğŸš€ Quick Reference]]

---

## ğŸ”¢ COUNT Functions

### Basic Syntax Structure

```sql
COUNT(*) OVER()                    -- Total count across all rows
COUNT(*) OVER(PARTITION BY column) -- Count within each group
```

### Task 1: Total Orders Analysis

**Objective**: Find the total number of orders and orders per customer

```sql
SELECT
    OrderID,
    OrderDate,
    CustomerID,
    COUNT(*) OVER() AS TotalOrders,
    COUNT(*) OVER(PARTITION BY CustomerID) AS OrdersByCustomers
FROM Sales.Orders;
```

**Expected Output:**

|OrderID|OrderDate|CustomerID|TotalOrders|OrdersByCustomers|
|---|---|---|---|---|
|1001|2024-01-15|CUST001|1500|25|
|1002|2024-01-16|CUST001|1500|25|
|1003|2024-01-17|CUST002|1500|18|

> [!tip] Understanding the Results
> 
> - **TotalOrders**: Same value (1500) for every row - total count across entire table
> - **OrdersByCustomers**: Varies by customer - count of orders for each specific customer

### Task 2: Customer Statistics

**Objective**: Analyze different counting scenarios with NULL handling

```sql
SELECT
    *,
    COUNT(*) OVER () AS TotalCustomersStar,
    COUNT(1) OVER () AS TotalCustomersOne,
    COUNT(Score) OVER() AS TotalScores,
    COUNT(Country) OVER() AS TotalCountries
FROM Sales.Customers;
```

**Expected Output:**

|CustomerID|Score|Country|TotalCustomersStar|TotalCustomersOne|TotalScores|TotalCountries|
|---|---|---|---|---|---|---|
|CUST001|85|USA|100|100|95|98|
|CUST002|NULL|Canada|100|100|95|98|

> [!important] COUNT Variations Explained
> 
> - **COUNT(*)** and **COUNT(1)**: Count all rows including NULLs
> - **COUNT(column)**: Counts only non-NULL values in that column
> - This is why TotalScores (95) < TotalCustomers (100) - some scores are NULL

### Task 3: Duplicate Detection

**Objective**: Identify duplicate rows using window functions

```sql
SELECT 
    * 
FROM (
    SELECT 
        *,
        COUNT(*) OVER(PARTITION BY OrderID) AS CheckDuplicates
    FROM Sales.OrdersArchive
) t
WHERE CheckDuplicates > 1;
```

**Expected Output:**

|OrderID|OrderDate|CustomerID|CheckDuplicates|
|---|---|---|---|
|1005|2024-01-20|CUST003|2|
|1005|2024-01-20|CUST003|2|

> [!warning] Duplicate Detection Logic If `CheckDuplicates > 1`, the OrderID appears multiple times in the table. This technique is more efficient than self-joins for finding duplicates.

---

## â• SUM Functions

### Task 4: Sales Totals Analysis

**Objective**: Calculate total sales globally and by product

```sql
SELECT
    OrderID,
    OrderDate,
    Sales,
    ProductID,
    SUM(Sales) OVER () AS TotalSales,
    SUM(Sales) OVER (PARTITION BY ProductID) AS SalesByProduct
FROM Sales.Orders;
```

**Expected Output:**

|OrderID|OrderDate|Sales|ProductID|TotalSales|SalesByProduct|
|---|---|---|---|---|---|
|1001|2024-01-15|1500|PROD001|150000|25000|
|1002|2024-01-16|2200|PROD001|150000|25000|
|1003|2024-01-17|1800|PROD002|150000|18000|

### Task 5: Percentage Contribution

**Objective**: Calculate each product's percentage of total sales

```sql
SELECT
    OrderID,
    ProductID,
    Sales,
    SUM(Sales) OVER () AS TotalSales,
    ROUND(CAST(Sales AS FLOAT) / SUM(Sales) OVER () * 100, 2) AS PercentageOfTotal
FROM Sales.Orders;
```

**Expected Output:**

|OrderID|ProductID|Sales|TotalSales|PercentageOfTotal|
|---|---|---|---|---|
|1001|PROD001|1500|150000|1.00|
|1002|PROD001|2200|150000|1.47|
|1003|PROD002|1800|150000|1.20|

> [!tip] Percentage Calculation Breakdown
> 
> ```sql
> -- Formula: (Individual Sale / Total Sales) * 100
> -- CAST(Sales AS FLOAT) prevents integer division
> -- ROUND(..., 2) gives 2 decimal places
> ```

---

## ğŸ“Š AVG Functions

### Task 6: Average Sales Analysis

**Objective**: Calculate average sales globally and by product

```sql
SELECT
    OrderID,
    OrderDate,
    Sales,
    ProductID,
    AVG(Sales) OVER () AS AvgSales,
    AVG(Sales) OVER (PARTITION BY ProductID) AS AvgSalesByProduct
FROM Sales.Orders;
```

**Expected Output:**

|OrderID|OrderDate|Sales|ProductID|AvgSales|AvgSalesByProduct|
|---|---|---|---|---|---|
|1001|2024-01-15|1500|PROD001|1875.50|2100.00|
|1002|2024-01-16|2200|PROD001|1875.50|2100.00|
|1003|2024-01-17|1800|PROD002|1875.50|1650.75|

### Task 7: Handling NULL Values in Averages

**Objective**: Compare averages with and without NULL handling

```sql
SELECT
    CustomerID,
    LastName,
    Score,
    COALESCE(Score, 0) AS CustomerScore,
    AVG(Score) OVER () AS AvgScore,
    AVG(COALESCE(Score, 0)) OVER () AS AvgScoreWithoutNull
FROM Sales.Customers;
```

**Expected Output:**

|CustomerID|LastName|Score|CustomerScore|AvgScore|AvgScoreWithoutNull|
|---|---|---|---|---|---|
|CUST001|Johnson|85|85|78.50|74.25|
|CUST002|Smith|NULL|0|78.50|74.25|

> [!note] NULL Handling in Averages
> 
> - **AVG(Score)**: Ignores NULL values completely
> - **AVG(COALESCE(Score, 0))**: Treats NULL as 0, affecting the average
> - COALESCE replaces NULL with specified default value

### Task 8: Above-Average Sales Filter

**Objective**: Find orders with sales above overall average

```sql
SELECT
    *
FROM (
    SELECT
        OrderID,
        ProductID,
        Sales,
        AVG(Sales) OVER () AS Avg_Sales
    FROM Sales.Orders
) t 
WHERE Sales > Avg_Sales;
```

**Expected Output:**

|OrderID|ProductID|Sales|Avg_Sales|
|---|---|---|---|
|1002|PROD001|2200|1875.50|
|1005|PROD003|2500|1875.50|
|1008|PROD001|1950|1875.50|

---

## ğŸ“ˆ MAX/MIN Functions

### Task 9: Basic Min/Max Analysis

**Objective**: Find highest and lowest sales (traditional approach)

```sql
SELECT 
    MIN(Sales) AS MinSales, 
    MAX(Sales) AS MaxSales 
FROM Sales.Orders;
```

**Expected Output:**

|MinSales|MaxSales|
|---|---|
|150.00|5000.00|

### Task 10: Min/Max with Window Functions

**Objective**: Show min/max alongside individual records

```sql
SELECT 
    OrderID,
    ProductID,
    OrderDate,
    Sales,
    MIN(Sales) OVER () AS LowestSales,
    MIN(Sales) OVER (PARTITION BY ProductID) AS LowestSalesByProduct
FROM Sales.Orders;
```

**Expected Output:**

|OrderID|ProductID|OrderDate|Sales|LowestSales|LowestSalesByProduct|
|---|---|---|---|---|---|
|1001|PROD001|2024-01-15|1500|150.00|800.00|
|1002|PROD001|2024-01-16|2200|150.00|800.00|
|1003|PROD002|2024-01-17|1800|150.00|300.00|

### Task 11: Top Performers Identification

**Objective**: Find employees with highest salaries

```sql
SELECT *
FROM (
    SELECT *,
           MAX(Salary) OVER() AS HighestSalary
    FROM Sales.Employees
) t
WHERE Salary = HighestSalary;
```

**Expected Output:**

|EmployeeID|FirstName|LastName|Salary|HighestSalary|
|---|---|---|---|---|
|EMP015|Sarah|Wilson|95000|95000|
|EMP023|Michael|Brown|95000|95000|

### Task 12: Deviation Analysis

**Objective**: Calculate how far each sale is from min/max values

```sql
SELECT
    OrderID,
    OrderDate,
    ProductID,
    Sales,
    MAX(Sales) OVER () AS HighestSales,
    MIN(Sales) OVER () AS LowestSales,
    Sales - MIN(Sales) OVER () AS DeviationFromMin,
    MAX(Sales) OVER () - Sales AS DeviationFromMax
FROM Sales.Orders;
```

**Expected Output:**

|OrderID|OrderDate|ProductID|Sales|HighestSales|LowestSales|DeviationFromMin|DeviationFromMax|
|---|---|---|---|---|---|---|---|
|1001|2024-01-15|PROD001|1500|5000|150|1350|3500|
|1002|2024-01-16|PROD001|2200|5000|150|2050|2800|

> [!tip] Interpreting Deviations
> 
> - **DeviationFromMin**: How much above the minimum (positive is good)
> - **DeviationFromMax**: How much below the maximum (smaller is better)
> - Useful for identifying outliers and performance gaps

---

## ğŸ”„ Rolling Calculations

### Understanding Window Frames

> [!important] Window Frame Concepts Window frames define which rows to include in calculations:
> 
> - **Unbounded**: All rows in partition
> - **Current Row**: Just the current row
> - **N Preceding/Following**: N rows before/after current row
> - **Range vs Rows**: Value-based vs position-based boundaries

### Task 13: Moving Average (Cumulative)

**Objective**: Calculate cumulative moving average by product over time

```sql
SELECT
    OrderID,
    ProductID,
    OrderDate,
    Sales,
    AVG(Sales) OVER (PARTITION BY ProductID) AS AvgByProduct,
    AVG(Sales) OVER (PARTITION BY ProductID ORDER BY OrderDate) AS MovingAvg
FROM Sales.Orders;
```

**Expected Output:**

|OrderID|ProductID|OrderDate|Sales|AvgByProduct|MovingAvg|
|---|---|---|---|---|---|
|1001|PROD001|2024-01-15|1500|2100.00|1500.00|
|1002|PROD001|2024-01-16|2200|2100.00|1850.00|
|1004|PROD001|2024-01-18|2500|2100.00|2066.67|

> [!note] Moving Average Explanation
> 
> - **AvgByProduct**: Static average across all orders for the product
> - **MovingAvg**: Changes with each row, including only orders up to current date
> - Row 1: (1500) / 1 = 1500.00
> - Row 2: (1500 + 2200) / 2 = 1850.00
> - Row 3: (1500 + 2200 + 2500) / 3 = 2066.67

### Task 14: Rolling Average (Fixed Window)

**Objective**: Calculate 2-row rolling average (current + next order)

```sql
SELECT
    OrderID,
    ProductID,
    OrderDate,
    Sales,
    AVG(Sales) OVER (
        PARTITION BY ProductID 
        ORDER BY OrderDate 
        ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING
    ) AS RollingAvg
FROM Sales.Orders;
```

**Expected Output:**

|OrderID|ProductID|OrderDate|Sales|RollingAvg|
|---|---|---|---|---|
|1001|PROD001|2024-01-15|1500|1850.00|
|1002|PROD001|2024-01-16|2200|2350.00|
|1004|PROD001|2024-01-18|2500|2500.00|

> [!tip] Rolling Window Explanation
> 
> - **ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING**: Current row + next row
> - Row 1: (1500 + 2200) / 2 = 1850.00 (current + next)
> - Row 2: (2200 + 2500) / 2 = 2350.00 (current + next)
> - Row 3: (2500) / 1 = 2500.00 (only current, no next row)

---

## ğŸš€ Quick Reference

### Window Function Syntax

```sql
function_name(column) OVER (
    [PARTITION BY column1, column2, ...]
    [ORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...]
    [ROWS|RANGE BETWEEN start AND end]
)
```

### Common Patterns

|Pattern|Purpose|Example|
|---|---|---|
|`OVER()`|Entire result set|`SUM(sales) OVER()`|
|`OVER(PARTITION BY col)`|Group by column|`AVG(score) OVER(PARTITION BY dept)`|
|`OVER(ORDER BY col)`|Running calculation|`SUM(sales) OVER(ORDER BY date)`|
|`OVER(PARTITION BY col ORDER BY col2)`|Group + running|`ROW_NUMBER() OVER(PARTITION BY dept ORDER BY salary DESC)`|

### Window Frame Options

|Frame|Description|Use Case|
|---|---|---|
|`ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`|From start to current|Running totals|
|`ROWS BETWEEN 2 PRECEDING AND CURRENT ROW`|Last 3 rows including current|3-period moving average|
|`ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING`|Current and next row|Forward-looking metrics|
|`ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`|All rows (default)|Overall statistics|

### Performance Tips

> [!tip] Optimization Best Practices
> 
> 1. **Index ORDER BY columns** - Improves window function performance
> 2. **Limit partitions** - Too many small partitions can be inefficient
> 3. **Use appropriate frame bounds** - Avoid unnecessary calculations
> 4. **Consider materialized views** - For frequently used window calculations

### Common Use Cases

- **ğŸ“ˆ Financial Analysis**: Running totals, moving averages, percentage of total
- **ğŸ† Rankings**: Top performers, percentile rankings, comparative analysis
- **ğŸ“Š Business Intelligence**: Period-over-period comparisons, trend analysis
- **ğŸ” Data Quality**: Duplicate detection, outlier identification
- **ğŸ“‹ Reporting**: Subtotals, grand totals alongside detail rows

---

## Tags

#sql #window-functions #aggregate-functions #analytics #database #data-analysis #rolling-calculations #moving-averages #business-intelligence