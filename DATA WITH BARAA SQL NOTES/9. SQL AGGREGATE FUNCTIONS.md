# ğŸŒŸ **Mastering SQL Window Aggregate Functions**  

---

## ğŸ“š **Overview: What Are Window Aggregate Functions?**

Window functions allow you to perform **aggregate calculations** (like `COUNT`, `SUM`, `AVG`, `MAX`, `MIN`) over a **set of rows related to the current row**, without collapsing the result set into a single output â€” unlike traditional `GROUP BY`.

They are ideal when you want:
- To **retain individual row details**
- To compute **running totals, moving averages, rankings, or comparisons**
- To avoid complex subqueries

---

## ğŸ”§ **Syntax Structure**

```sql
AGGREGATE_FUNCTION(expression) OVER (
    [PARTITION BY partition_expression]
    [ORDER BY sort_expression]
    [ROWS/RANGE frame_clause]
)
```

| Clause | Purpose |
|-------|--------|
| `OVER()` | Defines the window |
| `PARTITION BY` | Groups rows (like `GROUP BY`, but per-row) |
| `ORDER BY` | Orders rows within the partition |
| `ROWS BETWEEN ...` | Defines frame (e.g., rolling window) |

---

# 1ï¸âƒ£ `COUNT()` â€“ Counting Rows with Context

### âœ… **Task 1: Total Orders & Orders per Customer**

```sql
SELECT
    OrderID,
    OrderDate,
    CustomerID,
    COUNT(*) OVER() AS TotalOrders,
    COUNT(*) OVER(PARTITION BY CustomerID) AS OrdersByCustomer
FROM Sales.Orders;
```

#### ğŸ§ª **Expected Output Example:**

| OrderID | OrderDate   | CustomerID | TotalOrders | OrdersByCustomer |
|---------|-------------|------------|-------------|------------------|
| 101     | 2023-01-05  | C001       | 6           | 3                |
| 102     | 2023-01-06  | C002       | 6           | 2                |
| 103     | 2023-01-07  | C001       | 6           | 3                |

> ğŸ” `TotalOrders = 6` (total across all data), `OrdersByCustomer` varies by customer.

---

### âœ… **Task 2: Count Different Aspects in Customers Table**

```sql
SELECT
    *,
    COUNT(*) OVER () AS TotalCustomersStar,
    COUNT(1) OVER () AS TotalCustomersOne,
    COUNT(Score) OVER() AS TotalScores,
    COUNT(Country) OVER() AS TotalCountries
FROM Sales.Customers;
```

> ğŸ’¡ `COUNT(*)` and `COUNT(1)` both count all rows (including NULLs).  
> `COUNT(column)` ignores `NULL` values.

#### ğŸ§ª **Output Insight:**

| CustomerID | Score | Country | TotalCustomersStar | TotalScores | TotalCountries |
|------------|-------|---------|--------------------|-------------|----------------|
| C001       | 85    | USA     | 5                  | 4           | 5              |
| C002       | NULL  | UK      | 5                  | 4           | 5              |

> âš ï¸ `TotalScores = 4` because one `Score` is `NULL`.

---

### âœ… **Task 3: Detect Duplicates in `OrdersArchive`**

```sql
SELECT * 
FROM (
    SELECT 
        *,
        COUNT(*) OVER(PARTITION BY OrderID) AS CheckDuplicates
    FROM Sales.OrdersArchive
) t
WHERE CheckDuplicates > 1;
```

#### ğŸ§ª **Output: Only Duplicate Rows**

| OrderID | OrderDate   | ... | CheckDuplicates |
|--------|-------------|-----|------------------|
| 205    | 2023-03-10  | ... | 2                |
| 205    | 2023-03-10  | ... | 2                |

> âœ… This finds **exact duplicates** based on `OrderID`. Use more columns if needed.

---

# 2ï¸âƒ£ `SUM()` â€“ Aggregating Values Over Windows

### âœ… **Task 4: Total Sales & Sales by Product**

```sql
SELECT
    OrderID,
    OrderDate,
    Sales,
    ProductID,
    SUM(Sales) OVER () AS TotalSales,
    SUM(Sales) OVER (PARTITION BY ProductID) AS SalesByProduct
FROM Sales.Orders;
```

#### ğŸ§ª **Example Output:**

| OrderID | ProductID | Sales | TotalSales | SalesByProduct |
|--------|-----------|-------|------------|----------------|
| 101    | P001      | 200   | 1500       | 600            |
| 102    | P002      | 300   | 1500       | 900            |
| 103    | P001      | 400   | 1500       | 600            |

> ğŸ’¡ `SalesByProduct`: All `P001` share same total sum.

---

### âœ… **Task 5: Percentage of Total Sales per Order**

```sql
SELECT
    OrderID,
    ProductID,
    Sales,
    SUM(Sales) OVER () AS TotalSales,
    ROUND(CAST(Sales AS FLOAT) / SUM(Sales) OVER () * 100, 2) AS PercentageOfTotal
FROM Sales.Orders;
```

#### ğŸ§ª **Output:**

| OrderID | Sales | TotalSales | PercentageOfTotal |
|--------|-------|------------|-------------------|
| 101    | 200   | 1500       | 13.33             |
| 102    | 300   | 1500       | 20.00             |

> ğŸ“Š Useful for **sales contribution analysis**.

---

# 3ï¸âƒ£ `AVG()` â€“ Compute Averages Without Grouping

### âœ… **Task 6: Average Sales Overall & by Product**

```sql
SELECT
    OrderID,
    OrderDate,
    Sales,
    ProductID,
    AVG(Sales) OVER () AS AvgSales,
    AVG(Sales) OVER (PARTITION BY ProductID) AS AvgSalesByProduct
FROM Sales.Orders;
```

#### ğŸ§ª **Sample Output:**

| OrderID | ProductID | Sales | AvgSales | AvgSalesByProduct |
|--------|-----------|-------|----------|-------------------|
| 101    | P001      | 200   | 250.00   | 300.00            |
| 102    | P002      | 300   | 250.00   | 225.00            |

> ğŸ“ˆ Helps compare individual sales to **global or product-level average**.

---

### âœ… **Task 7: Handle NULLs in Average Calculation**

```sql
SELECT
    CustomerID,
    LastName,
    Score,
    COALESCE(Score, 0) AS CustomerScore,
    AVG(Score) OVER () AS AvgScore,
    AVG(COALESCE(Score, 0)) OVER () AS AvgScoreWithoutNull
FROM Sales.Customers;
```

#### ğŸ§ª **Key Insight:**

| Score | AvgScore | AvgScoreWithoutNull |
|-------|----------|----------------------|
| 85    | 76.25    | 68.75                |
| NULL  | 76.25    | 68.75                |
| 70    | 76.25    | 68.75                |

> âš ï¸ `AVG(Score)` ignores `NULL`s â†’ higher average  
> `AVG(COALESCE(...))` treats `NULL` as `0` â†’ lower average

---

### âœ… **Task 8: Find Orders Above Average Sales**

```sql
SELECT *
FROM (
    SELECT
        OrderID,
        ProductID,
        Sales,
        AVG(Sales) OVER () AS Avg_Sales
    FROM Sales.Orders
) t 
WHERE Sales > Avg_Sales;
```

#### ğŸ§ª **Output: Only High-Value Orders**

| OrderID | ProductID | Sales | Avg_Sales |
|--------|-----------|-------|-----------|
| 104    | P001      | 400   | 250.00    |
| 105    | P002      | 350   | 250.00    |

> ğŸ” Great for **outlier detection** or **performance benchmarking**.

---

# 4ï¸âƒ£ `MAX()` / `MIN()` â€“ Finding Extremes

### âœ… **Task 9: Global Min & Max Sales (Baseline)**

```sql
SELECT 
    MIN(Sales) AS MinSales, 
    MAX(Sales) AS MaxSales 
FROM Sales.Orders;
```

#### ğŸ§ª **Single Row Output:**

| MinSales | MaxSales |
|---------|----------|
| 100     | 500      |

> âš ï¸ Not a window function yet â€” just baseline.

---

### âœ… **Task 10: Lowest Sales Overall & by Product**

```sql
SELECT 
    OrderID,
    ProductID,
    OrderDate,
    Sales,
    MIN(Sales) OVER () AS LowestSales,
    MIN(Sales) OVER (PARTITION BY ProductID) AS LowestSalesByProduct
FROM Sales.Orders;
```

#### ğŸ§ª **Output:**

| OrderID | ProductID | Sales | LowestSales | LowestSalesByProduct |
|--------|-----------|-------|-------------|-----------------------|
| 101    | P001      | 200   | 100         | 150                   |
| 102    | P002      | 300   | 100         | 100                   |

> ğŸ” Compare each sale to **overall floor** and **product-specific floor**.

---

### âœ… **Task 11: Employees with Highest Salary**

```sql
SELECT *
FROM (
    SELECT *,
           MAX(Salary) OVER() AS HighestSalary
    FROM Sales.Employees
) t
WHERE Salary = HighestSalary;
```

#### ğŸ§ª **Returns Top Earners Only**

| EmployeeID | Name   | Salary | HighestSalary |
|------------|--------|--------|---------------|
| E101       | Alice  | 95000  | 95000         |

> âœ… Works even with **multiple employees** at max salary.

---

### âœ… **Task 12: Deviation from Min & Max Sales**

```sql
SELECT
    OrderID,
    OrderDate,
    ProductID,
    Sales,
    MAX(Sales) OVER () AS HighestSales,
    MIN(Sales) OVER () AS LowestSales,
    Sales - MIN(Sales) OVER () AS DeviationFromMin,
    MAX(Sales) OVER () - Sales AS DeviationFromMax
FROM Sales.Orders;
```

#### ğŸ§ª **Insightful Comparison:**

| Sales | HighestSales | LowestSales | DeviationFromMin | DeviationFromMax |
|-------|--------------|-------------|------------------|------------------|
| 200   | 500          | 100         | 100              | 300              |
| 500   | 500          | 100         | 400              | 0                |

> ğŸ“Š Use for **performance gap analysis**.

---

# ğŸ”„ Use Case: Rolling Sum & Moving Average

### âœ… **Task 13: Moving Average Over Time (Unbounded)**

```sql
SELECT
    OrderID,
    ProductID,
    OrderDate,
    Sales,
    AVG(Sales) OVER (PARTITION BY ProductID) AS AvgByProduct,
    AVG(Sales) OVER (PARTITION BY ProductID ORDER BY OrderDate) AS MovingAvg
FROM Sales.Orders
ORDER BY ProductID, OrderDate;
```

#### ğŸ§ª **Moving Average Grows Over Time:**

For `ProductID = P001`:

| OrderDate   | Sales | MovingAvg (cumulative) |
|-------------|-------|------------------------|
| 2023-01-05  | 200   | 200.00                 |
| 2023-01-10  | 400   | 300.00                 |
| 2023-01-15  | 300   | 300.00                 |

> ğŸ“ˆ Cumulative average increases gradually.

---

### âœ… **Task 14: Rolling Average â€“ Current + Next Order**

```sql
SELECT
    OrderID,
    ProductID,
    OrderDate,
    Sales,
    AVG(Sales) OVER (
        PARTITION BY ProductID 
        ORDER BY OrderDate 
        ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING
    ) AS RollingAvg
FROM Sales.Orders;
```

#### ğŸ§ª **Output: Two-Row Average**

| OrderDate   | Sales | RollingAvg |
|-------------|-------|------------|
| 2023-01-05  | 200   | 300.00     | â†’ (200+400)/2
| 2023-01-10  | 400   | 350.00     | â†’ (400+300)/2
| 2023-01-15  | 300   | 300.00     | â†’ only itself (no next)

> ğŸ¯ Ideal for **short-term trend smoothing**.

---

# ğŸ§  **Summary Table: Key Window Aggregates**

| Function | Use Case | Example |
|--------|----------|--------|
| `COUNT()` | Count rows globally or per group | `COUNT(*) OVER(PARTITION BY CustomerID)` |
| `SUM()` | Running total or grouped sum | `SUM(Sales) OVER(PARTITION BY Product)` |
| `AVG()` | Compare to average dynamically | `AVG(Sales) OVER()` |
| `MIN()/MAX()` | Identify extremes | `MAX(Salary) OVER()` |
| `ROWS BETWEEN` | Define rolling windows | `ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING` |

---

# ğŸ› ï¸ **Best Practices & Tips**

1. **Always use `OVER()`** â€” otherwise it's not a window function!
2. **`PARTITION BY` = group logic**, `ORDER BY` = sort within group.
3. **Handle `NULL`s carefully** â€” they affect `AVG`, `SUM`, etc.
4. Use **`COALESCE`** or `ISNULL` when including `NULL` values skews results.
5. For **time-series**, always `ORDER BY` date.
6. **`ROWS BETWEEN`** gives precise control over window size.

---

# ğŸ§© **Pro Tip: Combine Multiple Window Functions**

```sql
SELECT
    OrderID,
    Sales,
    ProductID,
    SUM(Sales) OVER() AS Total,
    SUM(Sales) OVER(PARTITION BY ProductID) AS ProductTotal,
    AVG(Sales) OVER(PARTITION BY ProductID ORDER BY OrderDate) AS MovingAvg,
    RANK() OVER(ORDER BY Sales DESC) AS SalesRank
FROM Sales.Orders;
```

> ğŸš€ Enables **rich analytical insights** in one query.

---

# ğŸ“ **Obsidian-Friendly Markdown Features Used**
- âœ… Code blocks with syntax highlighting
- âœ… Tables for clarity
- âœ… Emoji for visual indexing
- âœ… Headers for navigation
- âœ… Callouts (via blockquotes) for key insights

> ğŸ’¡ Save this as `SQL - Window Aggregate Functions.md` in your vault!

---

# ğŸ“Œ Final Thoughts

Window functions are **game-changers** in SQL analytics. They help you:
- Avoid self-joins and subqueries
- Maintain granular detail while computing aggregates
- Perform advanced business logic (trends, rankings, deviations)

ğŸ¯ **Mastery Tip:** Practice rewriting `GROUP BY` queries using window functions â€” then decide which suits your use case better.

---

âœ… **You're now a SQL Window Functions Pro!**  
Use these notes daily â€” and watch your analytical queries level up. ğŸš€

--- 

> ğŸ”— *Link this note in your Obsidian graph as: `[[SQL Window Functions]]`*  
> ğŸ·ï¸ Tags: `#sql #window-functions #analytics #study-notes #obsidian`